<!DOCTYPE html>
<html lang="en" class="a">
	<head>
		<meta charset="utf-8">
		<!-- Testharness Timeout to long -> 60 Seconds-->
		<meta name="timeout" content="long">
		<title>WebRTC - Send Test</title>
		<script src="../resources/testharness.js"></script>
		<script src="../resources/testharnessreport.js"></script><link href="../resources/testharness.css" type="text/css" rel="stylesheet"/>
		<!-- Including the Firebase.js to send the ICE Candidate to the other peer-->
		<script type="text/javascript" src='https://cdn.firebase.com/v0/firebase.js'></script>
	</head>
	<body class="a">
		<div>
			<div id="signallingInfo"></div>
			
				
			
		</div>
		<hr />

		<!-- Testharness log -->
		<div id="log"></div>
		<script src="../datachannel2peers.js" type="text/javascript"></script>
		<script type="text/javascript">
            var label = "test";
            var data = "s", size = 10, repeats = 128, messageCount = 0, i = 0;
            for (var i = 0; i < size; i++) {
                data += data;
            }
            var expected = data.length;
            var dataChannelOptions1 = {
                negotiated : true,
                ordered : true,
                id : 333
            };
            var dataChannelOptions2 = {
                negotiated : true,
                ordered : false,
                id : 333
            };
            var test = async_test("Create two DataChannels with same id and negotiated = true - with asymmetric attribute ordered true/false - send  " + repeats + " times and receive - synchronous");
            if (offerer) {
                test.step(function() {
                    dataChannel = peerConnection.createDataChannel(label, dataChannelOptions1);
                    dataChannel.onopen = test.step_func(function() {
                        try {
                            for ( i = 0; i < repeats; i++) {
                                dataChannel.send(data);
                                data += "t";
                            }
                        } catch(e) {
                            assert_unreached("Can send " + i + " times before error " + e.name + ": " + e.message);
                        }
                    });
                    var temp = 1024;
                    dataChannel.onmessage = test.step_func(function(e) {
                        if (temp != e.data.length) {
                            console.log("ordered value should be " + temp + " but received " + e.data.length);
                        }
                        temp++;
                        messageCount++;

                        if (messageCount == repeats) {
                            test.done();
                        }
                    });
                });
            } else {
                test.step(function() {
                    dataChannel = peerConnection.createDataChannel(label, dataChannelOptions2);
                    dataChannel.onopen = test.step_func(function() {
                        try {
                            for ( i = 0; i < repeats; i++) {
                                dataChannel.send(data);
                                data += "t";
                            }
                        } catch(e) {
                            assert_unreached("Can send " + i + " times before error " + e.name + ": " + e.message);
                        }
                    });
                    dataChannel.onmessage = test.step_func(function(e) {
                        if ((e.data).length == expected) {
                            messageCount++;
                            expected++;
                        }
                        if (messageCount == repeats) {
                            test.done();
                        }
                    });
                });
            }
		</script>
	</body>
</html>

