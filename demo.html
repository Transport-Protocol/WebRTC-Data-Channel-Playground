<!DOCTYPE html>
<html>
	<head>
		<title>DataChannels WebRTC Demo</title>
		<script type='text/javascript' src='https://cdn.firebase.com/v0/firebase.js'></script>
		<script type='text/javascript' src='http://code.jquery.com/jquery-2.1.3.min.js'></script>
	</head>
	<body>
		<h1 id="link">WebRTC Data-Channel Demo</h1>

		<input id="Channel" type="text">
		<button onclick="manualConnect()">
			connect
		</button>
		<br>
		<br>
		NetPerfMeter
		<br>
		<input id="npmParameterSleepTXT">
		sleeptime
		<br>
		<input id="npmPackagecountTXT">
		number of messages
		<br>
		<input id="packagesize">
		size of one package (byte)
		<br>
		<button onclick="NetPerfMeter()">
			Start
		</button>
		<button id="closeChannel">
			close
		</button>
		<button id="createDataChannel">
			create Data-Channel
		</button>
		<h1>Chatlog - <span id="status"><span style="color:red">offline</span></span></h1>
		<div id="chatlog"></div>
		
		<div id="channelStatus"></div>

		<script>
			/*
			 BASED ON: http://louisstow.github.io/WebRTC/datachannels.html
			 */

			dcCounter = 0;
			$('#createDataChannel').click(function(){
				createDataChannel(++dcCounter);
			});
			
			$(".closeDataChannel").click(function(){				
				console.log("Dr√ºckmich" + this.data('channelLabel'));
				
				closeDataChannel(this.data('channelLabel'));				
			});
						
			$('#npmParameterSleepTXT').val(500);
			$('#npmPackagecountTXT').val(10);
			$('#packagesize').val(200);

			var t_duration = 0,
			    t_startNewPackage = 0;
			var messageencoder = 1;
			var npmSizetemp;
			var npmSizePerX;
			var npmPaket;

			var stat = {
				"t_start" : 0,
				"t_end" : 0,
				"t_counter" : 0,
				"npmSize" : 0,
				"npmParameterSleep" : 500,
				"npmPackagecount" : 10
			};

			// get a reference to our FireBase database and child element: rooms
			var dbRef = new Firebase("https://webrtc-data-channel.firebaseio.com/");
			var roomRef = dbRef.child("rooms");

			// shims - wrappers for webkit and mozilla connections
			var PeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
			var IceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
			var SessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.RTCSessionDescription;
			

			// generate a unique-ish string for storage in firebase
			function id() {
				return (Math.random() * 10000 + 10000 | 0).toString();
			}

			// wrapper to send data to FireBase
			// - room: 	room id - generated by id()-function or read from url
			function send(room, key, data) {
				roomRef.child(room).child(key).set(data);
			}

			// wrapper function to receive data from FireBase
			function recv(room, type, cb) {
				roomRef.child(room).child(type).on("value", function(snapshot, key) {
					var data = snapshot.val();
					if (data) {
						cb(data);
					}
				});
			}

			// generic error handler
			function errorHandler(err) {
				console.error(err);
			}

			// determine what type of peer we are,
			// offerer or answerer.
			var ROOM = location.hash.substr(1);
			var type = "answerer";
			var otherType = "offerer";

			// no room number specified, so create one
			// which makes us the offerer
			if (!ROOM) {
				ROOM = id();
				type = "offerer";
				otherType = "answerer";

				$('#link').append(" (offerer)");
			}

			if (type === "answerer") {
				$('#link').append(" (answerer)");
			};

			$('#link').append(" - <a href='#" + ROOM + "'>" + ROOM + "</a>");

			// generate a unique-ish room number
			var ME = id();

			// get references to the document tags
			var chatlog = document.getElementById("chatlog");
			var packagesize = document.getElementById("packagesize");

			// options for the PeerConnection
			var server = {
				iceServers : [{
					url : "stun:23.21.150.121"
				}, {
					url : "stun:stun.l.google.com:19302"
				}, {
					url : "turn:numb.viagenie.ca",
					credential : "webrtcdemo",
					username : "louis%40mozilla.com"
				}]
			};

			var options = {
				optional : [{
					DtlsSrtpKeyAgreement : true
				}, {
					RtpDataChannels : true
				} //required for Firefox
				]
			};

			// create the PeerConnection
			var pc = new PeerConnection(server, options);

			pc.onicecandidate = function(e) {
				// take the first candidate that isn't null
				if (!e.candidate) {
					return;
				}
				pc.onicecandidate = null;

				// request the other peers ICE candidate
				recv(ROOM, "candidate:" + otherType, function(candidate) {
					pc.addIceCandidate(new IceCandidate(JSON.parse(candidate)));
				});

				// send our ICE candidate
				send(ROOM, "candidate:" + type, JSON.stringify(e.candidate));
			};

			// constraints on the offer SDP.
			var constraints = {};

			// define the channel var
			var channels = Array();


			connect();
			

			// start start peer connection
			function connect() {
				if (type === "offerer") {
					$('#createDataChannel').prop("disabled", false);// Button "createDataChannel" anabled for offerer

					createDataChannel(++dcCounter);
					// create the offer SDP
					pc.createOffer(function(offer) {
						pc.setLocalDescription(offer);

						// send the offer SDP to FireBase
						send(ROOM, "offer", JSON.stringify(offer));

						// wait for an answer SDP from FireBase
						recv(ROOM, "answer", function(answer) {
							pc.setRemoteDescription(new SessionDescription(JSON.parse(answer)));
						});
					}, errorHandler, constraints);
					
					console.log("creating offer");

				} else {			
					$('#createDataChannel').prop("disabled", true);// Button "createDataChannel" disabled for answerer

					// answerer must wait for the data channel
					pc.ondatachannel = function(e) {
						var channel = e.channel;
						bindEvents(channel);
						channels[channel.label] = channel;
						console.log('incoming datachannel');
						$('#channelStatus').append('<div id="'+channel.label+'">'+channel.label+' <span class="status">connecting</span></div>');
					};

					// answerer needs to wait for an offer before
					// generating the answer SDP
					recv(ROOM, "offer", function(offer) {
						pc.setRemoteDescription(new SessionDescription(JSON.parse(offer)));

						// now we can generate our answer SDP
						pc.createAnswer(function(answer) {
							pc.setLocalDescription(answer);

							// send it to FireBase
							send(ROOM, "answer", JSON.stringify(answer));
						}, errorHandler, constraints);
					});
					console.log('connect passive');
				}
			}

			//Create Datachannels
			function createDataChannel(label) {
				// offerer creates the data channel
				var tempChannel = pc.createDataChannel(label, {});
				bindEvents(tempChannel);
				channels[label] = tempChannel;
				console.log("creating datachannel");
				$('#channelStatus').append('<div id="'+label+'">'+label+' <span class="status">connecting</span></div>');
			}
			
			function closeDataChannel(label) {
				channels[label].close();
			}

			//
			function NetPerfMeter() {
				stat.npmSize = $('#packagesize').val();
				stat.npmPackagecount = $('#npmPackagecountTXT').val();
				stat.npmParameterSleep = npmParameterSleepTXT.value;
				var DataArray = new Array(1, stat.npmParameterSleep, stat.npmSize, stat.npmPackagecount);
				var DataString = DataArray.join(";");

				channels[1].send(DataString);
				var counter = 0;
				console.log(stat.npmParameterSleep);

				setTimeout(funct, stat.npmParameterSleep);
				var funct = function() {
				};
				var func = function() {
					npmPaket = "a";
					for (var j = 0; j < stat.npmSize; j++) {
						npmPaket += "a";
					}
					try {
						channels[1].send(npmPaket);
					} catch(e) {
						alert("Test Aborted!");
						return;
					}
					counter++;
					if (counter < stat.npmPackagecount)
						setTimeout(func, stat.npmParameterSleep);

				};
				func();
			}

			// bind the channel events
			function bindEvents(channel) {
				channel.onopen = function() {
					$('#'+channel.label+' span.status').html('open <button onclick="closeDataChannel(\''+channel.label+'\');">close</button>');
					console.log("Channel Open - Label:" + channel.label);
				};

				channel.onclose = function(e) {
					$('#'+channel.label+' span.status').html(channel.readyState);
					console.log("Channel Close");
				};

				window.onbeforeunload = function() {
					channel.close();
				};

				channel.onmessage = function(e) {
					// add the message to the chat log
					rxData = e.data.toString();
					console.log(rxData);
					var rxnpmPaketTemp = rxData.split(";");
					if (rxnpmPaketTemp[0] == 1) {
						alert("start test");
						messageencoder = 1;
					} else
						messageencoder = 2;

					switch(messageencoder) {
						case 1:
							npmSizePerX = 0; stat.t_counter = 0; stat.npmPackagecount = 0;
							var rxDataString = rxData;
							var rxDataArray = rxDataString.split(";");
							stat.npmParameterSleep 	= 	parseInt(rxDataArray[1]);
							stat.npmSize 			= 	parseInt(rxDataArray[2]); npmSizetemp = stat.npmSize;
							stat.npmPackagecount 	= 	rxDataArray[3];

							stat.t_start = new Date().getTime();
							alert(stat.t_start);
							break;
						case 2:
							alert(stat.t_start);
							stat.t_end = new Date().getTime();

							var returnArray = calculation(stat.npmSize, npmSizetemp, stat.t_start, stat.t_end, t_startNewPackage);
							stat.npmSize 	= 	returnArray[0];	
							npmSizetemp 	= 	returnArray[1];
							
							stat.npmSize = stat.npmSize + npmSizetemp;
							t_startNewPackage = new Date().getTime();
							stat.t_counter++
							if (stat.t_counter == stat.npmPackagecount) {
								alert("test completes successfully");
							}
							break;
					}
				};
			}
			
			


			// send a message the textbox throught
			// the data channel for a chat program
			function sendMessage() {
				var msg = packagesize.value;
				channel.send(msg);
				$('div#chatlog').append("<div>Me: " + msg + "</div>");
				packagesize.value = "";
			}


			$('#closeChannel').click(function() {
				alert('zr');
				channel.close();
				channel2.close();
			});

			function calculation(size, sizetemp, start, end, startNewPackage){
				stat.npmSize 		= parseInt(size);
				npmSizetemp 		= parseInt(sizetemp);
				stat.t_start		= parseInt(start);
				stat.t_end 			= parseInt(end);
				t_startNewPackage 	= parseInt(startNewPackage);
			
				//t_duration musst > 0
				t_duration = stat.t_end - stat.t_start;
				if (t_duration < 1)
					t_duration = 1;

				//calculate the average of Byte/s
				npmSizePerX = parseFloat((stat.npmSize * (1 / (t_duration / 1000))) / 1024);
				npmSizePerX = parseFloat(npmSizePerX * 1000);
				var npmSizePerX2 = Math.round(npmSizePerX);
				npmSizePerX2 = npmSizePerX2 / 1000;
				var npmSizePerX3 = (npmSizePerX2 / 1024) * 1000000;
				npmSizePerX3 = Math.round(npmSizePerX3);
				npmSizePerX3 = npmSizePerX3 / 1000000;

				//calculazion of the current Byte/s
				npmSizePerX = (Math.round(((npmSizetemp * (1 / ((stat.t_end - t_startNewPackage) / 1000))) / 1024) * 1000)) / 1000;

				$('div#chatlog').html("<div>current<br>" + npmSizePerX + " kByte/s<br>average<br>" + npmSizePerX2 + " kByte/s<br>" + npmSizePerX3 + " MByte/s</div>");

				console.log("GesGr.=" + stat.npmSize + " Byte/s=" + npmSizePerX + " kByte/s=" + npmSizePerX2 + " MByte/s=" + npmSizePerX3 + " Start=" + stat.t_start + " Ende=" + stat.t_end + " GesT=" + t_duration);


				return [stat.npmSize, npmSizetemp];
			}

		</script>

	</body>
</html>
