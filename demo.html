<!DOCTYPE html>
<html>
	<head>
		<title>DataChannels WebRTC Demo</title>
		<script type='text/javascript' src='https://cdn.firebase.com/v0/firebase.js'></script>
		<script type='text/javascript' src='http://code.jquery.com/jquery-2.1.3.min.js'></script>
	</head>
	<body>
		<h1 id="link">WebRTC Data-Channel Demo</h1>

		<input id="Channel" type="text">
		<button onclick="manualConnect()">
			connect
		</button>
		<br>
		<br>
		NetPerfMeter
		<br>
		<input id="npmParamSleep" value="1000">
		sleeptime
		<br>
		<input id="npmParamPktCount" value="10">
		number of messages
		<br>
		<input id="npmParamPktSize" value="10">
		size of one package (byte)
		<br>
		<button id="startNPM" onclick="NetPerfMeter()">
			Start NPM
		</button>
		<button id="createDataChannel">
			Create DC
		</button>
		
		<div id="channelStatus"></div>
		<div id="log"></div>

		<script>
			/*
			 BASED ON: http://louisstow.github.io/WebRTC/datachannels.html
			 */

			var dcCounter = 0;
			var t_duration = 0,
			    t_startNewPackage = 0;
			var messageencoder = 1;
			var npmSizetemp;
			var npmSizePerX;
			var npmPaket;
			var sentPktCounter = 0;

			var stat = {
				"t_start" : 0,
				"t_end" : 0,
				"t_counter" : 0,
				"npmSize" : 0,
				"npmParameterSleep" : 500,
				"npmPackagecount" : 10
			};

			// get a reference to our FireBase database and child element: rooms
			var dbRef = new Firebase("https://webrtc-data-channel.firebaseio.com/");
			var roomRef = dbRef.child("rooms");

			// shims - wrappers for webkit and mozilla connections
			var PeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
			var IceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
			var SessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.RTCSessionDescription;
			
			// #### Click functions
			$('#createDataChannel').click(function(){
				createDataChannel(++dcCounter);
			});
			
			// #### Functions
			// generate a unique-ish string for storage in firebase
			function id() {
				return (Math.random() * 10000 + 10000 | 0).toString();
			}

			// wrapper to send data to FireBase
			// - room: 	room id - generated by id()-function or read from url
			function send(room, key, data) {
				roomRef.child(room).child(key).set(data);
			}

			// wrapper function to receive data from FireBase
			function recv(room, type, cb) {
				roomRef.child(room).child(type).on("value", function(snapshot, key) {
					var data = snapshot.val();
					if (data) {
						cb(data);
					}
				});
			}

			// generic error handler
			function errorHandler(err) {
				console.error(err);
			}

			// determine what type of peer we are,
			// offerer or answerer.
			var ROOM = location.hash.substr(1);
			var type = "answerer";
			var otherType = "offerer";

			// no room number specified, so create one
			// which makes us the offerer
			if (!ROOM) {
				ROOM = id();
				type = "offerer";
				otherType = "answerer";

				$('#link').append(" (offerer)");
			}

			if (type === "answerer") {
				$('#link').append(" (answerer)");
			};

			$('#link').append(" - <a href='#" + ROOM + "'>" + ROOM + "</a>");

			// generate a unique-ish room number
			var ME = id();

			// get references to the document tags
			var chatlog = document.getElementById("chatlog");
			var packagesize = document.getElementById("packagesize");

			// options for the PeerConnection
			var iceServer = {
				iceServers : [{
					url : "stun:23.21.150.121"
				}, {
					url : "stun:stun.l.google.com:19302"
				}, {
					url : "turn:numb.viagenie.ca",
					credential : "webrtcdemo",
					username : "louis%40mozilla.com"
				}]
			};


			// create the PeerConnection
			var pc = new PeerConnection(iceServer);

			pc.onicecandidate = function(e) {
				// take the first candidate that isn't null
				if (!e.candidate) {
					return;
				}
				pc.onicecandidate = null;

				// request the other peers ICE candidate
				recv(ROOM, "candidate:" + otherType, function(candidate) {
					pc.addIceCandidate(new IceCandidate(JSON.parse(candidate)));
				});

				// send our ICE candidate
				send(ROOM, "candidate:" + type, JSON.stringify(e.candidate));
			};

			// constraints on the offer SDP.
			var constraints = {};

			// define the channel var
			var channels = Array();


			connect();
			

			// start start peer connection
			function connect() {
				if (type === "offerer") {
					$('#createDataChannel').prop("disabled", false);// Button "createDataChannel" anabled for offerer

					createDataChannel('init');
					// create the offer SDP
					pc.createOffer(function(offer) {
						pc.setLocalDescription(offer);

						// send the offer SDP to FireBase
						send(ROOM, "offer", JSON.stringify(offer));

						// wait for an answer SDP from FireBase
						recv(ROOM, "answer", function(answer) {
							pc.setRemoteDescription(new SessionDescription(JSON.parse(answer)));
						});
					}, errorHandler, constraints);
					
					console.log("creating offer");

				} else {			
					$('#createDataChannel').prop("disabled", true);// Button "createDataChannel" disabled for answerer

					// answerer must wait for the data channel
					pc.ondatachannel = function(e) {
						var channel = e.channel;
						bindEvents(channel);
						channels[channel.label] = channel;
						console.log('incoming datachannel');
						$('#channelStatus').append('<div id="dc_'+channel.label+'">'+channel.label+' <span class="status">connecting</span></div>');
					};

					// answerer needs to wait for an offer before
					// generating the answer SDP
					recv(ROOM, "offer", function(offer) {
						pc.setRemoteDescription(new SessionDescription(JSON.parse(offer)));

						// now we can generate our answer SDP
						pc.createAnswer(function(answer) {
							pc.setLocalDescription(answer);

							// send it to FireBase
							send(ROOM, "answer", JSON.stringify(answer));
						}, errorHandler, constraints);
					});
					console.log('connect passive');
				}
			}

			//Create Datachannels
			function createDataChannel(label) {
				// offerer creates the data channel
				
				var tempChannel = pc.createDataChannel(label);
				bindEvents(tempChannel);
				channels[tempChannel.label] = tempChannel;
				console.log("creating datachannel - id: " + tempChannel.id + ', label:' + tempChannel.label);
				$('#channelStatus').append('<div id="dc_'+tempChannel.label+'">'+tempChannel.label+' <span class="status">connecting</span></div>');
			}
			
			function closeDataChannel(label) {
				console.log('Channel ' + label +' - closing');
				channels[label].close();
			}
			function NpmSend() {
				console.log("Senden - sleep" + stat.npmParameterSleep);
				try {
						
					channels[1].send(npmPaket);
					sentPktCounter++;
					if (sentPktCounter < stat.npmPackagecount){
						setTimeout(NpmSend, stat.npmParameterSleep);
					}
				} catch(e) {
					alert("Test Aborted!");
					console.log(e);
					return;
				}
			};



			//
			function NetPerfMeter() {
				stat.npmSize = $('#npmParamPktSize').val();
				stat.npmPackagecount = $('#npmParamPktCount').val();
				stat.npmParameterSleep = parseInt($('#npmParamSleep').val());
				
				var DataArray = new Array(1, stat.npmParameterSleep, stat.npmSize, stat.npmPackagecount);
				var DataString = DataArray.join(";");

				channels[1].send(DataString);
				sentPktCounter = 0;
				console.log(stat.npmParameterSleep);

				setTimeout(funct, stat.npmParameterSleep);
				var funct = function() {
				};
				npmPaket = "a";
				for (var j = 0; j < stat.npmSize; j++) {
					npmPaket += "a";
				}

				NpmSend();
			}

			// bind the channel events
			function bindEvents(channel) {
				channel.onopen = function() {
					$('#dc_'+channel.label+' span.status').html('open <button onclick="closeDataChannel(\''+channel.label+'\');">close</button>');
					console.log("Channel Open - Label:" + channel.label + ', ID:' + channel.id);
				};

				channel.onclose = function(e) {
					$('#dc_'+channel.label+' span.status').html(channel.readyState);
					console.log("Channel Close");
				};

				window.onbeforeunload = function() {
					channel.close();
				};

				channel.onmessage = function(e) {
					// add the message to the chat log
					rxData = e.data.toString();
					console.log(rxData);
					var rxnpmPaketTemp = rxData.split(";");
					if (rxnpmPaketTemp[0] == 1) {
						//alert("start test");
						messageencoder = 1;
					} else
						messageencoder = 2;

					switch(messageencoder) {
						case 1:
							npmSizePerX = 0; stat.t_counter = 0; stat.npmPackagecount = 0;
							var rxDataString = rxData;
							var rxDataArray = rxDataString.split(";");
							stat.npmParameterSleep 	= 	parseInt(rxDataArray[1]);
							console.log(stat.npmParameterSleep);
							stat.npmSize 			= 	parseInt(rxDataArray[2]); npmSizetemp = stat.npmSize;
							stat.npmPackagecount 	= 	rxDataArray[3];

							stat.t_start = new Date().getTime();
							//alert(stat.t_start);
							break;
						case 2:
							//alert(stat.t_start);
							stat.t_end = new Date().getTime();

							var returnArray = calculation(stat.npmSize, npmSizetemp, stat.t_start, stat.t_end, t_startNewPackage);
							stat.npmSize 	= 	returnArray[0];	
							npmSizetemp 	= 	returnArray[1];
							
							stat.npmSize = stat.npmSize + npmSizetemp;
							t_startNewPackage = new Date().getTime();
							stat.t_counter++;
							if (stat.t_counter == stat.npmPackagecount) {
								alert("test completes successfully");
							}
							break;
					}
				};
			}
			


			function calculation(size, sizetemp, start, end, startNewPackage){
				stat.npmSize 		= parseInt(size);
				npmSizetemp 		= parseInt(sizetemp);
				stat.t_start		= parseInt(start);
				stat.t_end 			= parseInt(end);
				t_startNewPackage 	= parseInt(startNewPackage);
			
				//t_duration musst > 0
				t_duration = stat.t_end - stat.t_start;
				if (t_duration < 1)
					t_duration = 1;

				//calculate the average of Byte/s
				npmSizePerX = parseFloat((stat.npmSize * (1 / (t_duration / 1000))) / 1024);
				npmSizePerX = parseFloat(npmSizePerX * 1000);
				var npmSizePerX2 = Math.round(npmSizePerX);
				npmSizePerX2 = npmSizePerX2 / 1000;
				var npmSizePerX3 = (npmSizePerX2 / 1024) * 1000000;
				npmSizePerX3 = Math.round(npmSizePerX3);
				npmSizePerX3 = npmSizePerX3 / 1000000;

				//calculazion of the current Byte/s
				npmSizePerX = (Math.round(((npmSizetemp * (1 / ((stat.t_end - t_startNewPackage) / 1000))) / 1024) * 1000)) / 1000;

				$('div#log').html("<div>current<br>" + npmSizePerX + " " + (stat.t_counter+1) + " kByte/s<br>average<br>" + npmSizePerX2 + " kByte/s<br>" + npmSizePerX3 + " MByte/s</div>");

				console.log("GesGr.=" + stat.npmSize + " Byte/s=" + npmSizePerX + " kByte/s=" + npmSizePerX2 + " MByte/s=" + npmSizePerX3 + " Start=" + stat.t_start + " Ende=" + stat.t_end + " GesT=" + t_duration);


				return [stat.npmSize, npmSizetemp];
			}

		</script>

	</body>
</html>
