/*
 BASED ON: http://louisstow.github.io/WebRTC/datachannels.html
 */

 //stats
var stat = {
	t_start 			: 0,
	t_end 				: 0,
	t_counter 			: 0,
	npmSize 			: 0,
	npmParameterSleep 	: 500,
	npmPackagecount 	: 10,
	npm1SizePerX 		: 0,
	npm1SizePerX2		: 0,
	npm1SizePerX3		: 0,
};

var dcCounter = 0;
var t_duration = 0,
    t_startNewPackage = 0;
var messageencoder = 1;
var npmSizetemp;
var npmPaket;
var sentPktCounter = 0;
var stats = new Array();




// get a reference to our FireBase database and child element: rooms
var dbRef = new Firebase("https://webrtc-data-channel.firebaseio.com/");
var roomRef = dbRef.child("rooms");

// shims - wrappers for webkit and mozilla connections
var PeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
var IceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
var SessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.RTCSessionDescription;

// #### Click functions
$('#createDataChannel').click(function() {
	createDataChannel(++dcCounter);
});

// #### Functions
// generate a unique-ish string for storage in firebase
function id() {
	return (Math.random() * 10000 + 10000 | 0).toString();
}

// wrapper to send data to FireBase
// - room: 	room id - generated by id()-function or read from url
function send(room, key, data) {
	roomRef.child(room).child(key).set(data);
}

// wrapper function to receive data from FireBase
function recv(room, type, cb) {
	roomRef.child(room).child(type).on("value", function(snapshot, key) {
		var data = snapshot.val();
		if (data) {
			cb(data);
		}
	});
}

// generic error handler
function errorHandler(err) {
	console.error(err);
}

// determine what type of peer we are,
// offerer or answerer.
var ROOM = location.hash.substr(1);
var type = "answerer";
var otherType = "offerer";

// no room number specified, so create one
// which makes us the offerer
if (!ROOM) {
	ROOM = id();
	type = "offerer";
	otherType = "answerer";

	$('#link').append(" (offerer)");
}

if (type === "answerer") {
	$('#link').append(" (answerer)");
};

$('#link').append(" - <a href='#" + ROOM + "'>" + ROOM + "</a>");

// generate a unique-ish room number
var ME = id();

// get references to the document tags
var chatlog = document.getElementById("chatlog");
var packagesize = document.getElementById("packagesize");

// options for the PeerConnection
var iceServer = {
	iceServers : [{
		url : "stun:23.21.150.121"
	}, {
		url : "stun:stun.l.google.com:19302"
	}, {
		url : "turn:numb.viagenie.ca",
		credential : "webrtcdemo",
		username : "louis%40mozilla.com"
	}]
};

// create the PeerConnection
var pc = new PeerConnection(iceServer);

pc.onicecandidate = function(e) {
	// take the first candidate that isn't null
	if (!e.candidate) {
		return;
	}
	pc.onicecandidate = null;

	// request the other peers ICE candidate
	recv(ROOM, "candidate:" + otherType, function(candidate) {
		pc.addIceCandidate(new IceCandidate(JSON.parse(candidate)));
	});

	// send our ICE candidate
	send(ROOM, "candidate:" + type, JSON.stringify(e.candidate));
};

// constraints on the offer SDP.
var constraints = {};

// define the channel var
var channels = Array();

connect();

// start start peer connection
function connect() {
	if (type === "offerer") {
		$('#createDataChannel').prop("disabled", false);
		// Button "createDataChannel" anabled for offerer

		createDataChannel('init');
		// create the offer SDP
		pc.createOffer(function(offer) {
			pc.setLocalDescription(offer);

			// send the offer SDP to FireBase
			send(ROOM, "offer", JSON.stringify(offer));

			// wait for an answer SDP from FireBase
			recv(ROOM, "answer", function(answer) {
				pc.setRemoteDescription(new SessionDescription(JSON.parse(answer)));
			});
		}, errorHandler, constraints);

		console.log("creating offer");

	} else {
		$('#createDataChannel').prop("disabled", true);
		// Button "createDataChannel" disabled for answerer

		// answerer must wait for the data channel
		pc.ondatachannel = function(e) {
			var channel = e.channel;
			bindEvents(channel);
			channels[channel.label] = channel;
			console.log('incoming datachannel');
			stats[channel.label] = {
				t_start 			: 0,
				t_end 				: 0,
				t_counter 			: 0,
				npmSize 			: 0,
				npmParameterSleep 	: 500,
				npmPackagecount 	: 10,
				npm1SizePerX 		: 0,
				npm1SizePerX2		: 0,
				npm1SizePerX3		: 0,
			};
			$('#channelStatus').append('<div id="dc_' + channel.label + '">' + channel.label + ' <span class="status">connecting</span></div>');
		};

		// answerer needs to wait for an offer before
		// generating the answer SDP
		recv(ROOM, "offer", function(offer) {
			pc.setRemoteDescription(new SessionDescription(JSON.parse(offer)));

			// now we can generate our answer SDP
			pc.createAnswer(function(answer) {
				pc.setLocalDescription(answer);

				// send it to FireBase
				send(ROOM, "answer", JSON.stringify(answer));
			}, errorHandler, constraints);
		});
		console.log('connect passive');
	}
}

//Create Datachannels
function createDataChannel(label) {
	// 
	// var dataChannelOptions = {
	// 	maxRetransmitTime	: ,
	// 	maxRetransmits		: ,
	// }

	// offerer creates the data channel
	var tempChannel = pc.createDataChannel(label);
	bindEvents(tempChannel);
	channels[tempChannel.label] = tempChannel;

	stats[tempChannel.label] = {
		t_start 			: 0,
		t_end 				: 0,
		t_counter 			: 0,
		npmSize 			: 0,
		npmParameterSleep 	: 500,
		npmPackagecount 	: 10,
		npm1SizePerX 		: 0,
		npm1SizePerX2		: 0,
		npm1SizePerX3		: 0,
	};

	console.log("creating datachannel - id: " + tempChannel.id + ', label:' + tempChannel.label);
	$('#channelStatus').append('<div id="dc_' + tempChannel.label + '">' + tempChannel.label + ' <span class="status">connecting</span></div>');
}

function closeDataChannel(label) {
	console.log('Channel ' + label + ' - closing');
	channels[label].close();
}

function NpmSend(x, y) {
	console.log("Senden - sleep" + stat.npmParameterSleep);
	try {

		channels[x].send(y);
		sentPktCounter++;
		if (sentPktCounter < stat.npmPackagecount) {
			setTimeout(function(){
				NpmSend(x,y)
			}, stat.npmParameterSleep);
		}
	} catch(e) {
		alert("Test Aborted!");
		console.log(e);
		return;
	}
};

function funct() {
};

//
function NetPerfMeter() {	
	//console.log("Channel test. Channel: " + channels["init"].label + ". Status: " + channels["init"].readyState + ".");
	var channelNo = -1;

	// for (var i = 1; i < channels.length; i++) {		
	// 	console.log("Channel test. Channel: " + channels[i].label + ". Status: " + channels[i].readyState + ".");
	// 	if(channels[i].readyState == "open"){channelNo = i; break;}
	// };

	for(var key in channels) {
		console.log("Channel test. Channel: " + channels[key].label + ". Status: " + channels[key].readyState + ".");
		if(channels[key].readyState == "open") {
			channelNo = key;
			break;
		}
	}
	if(channelNo == -1){alert("No channel found"); return;}

	stat.npmSize = $('#npmParamPktSize').val();
	stat.npmPackagecount = $('#npmParamPktCount').val();
	stat.npmParameterSleep = parseInt($('#npmParamSleep').val());

	var DataArray = new Array(1, stat.npmParameterSleep, stat.npmSize, stat.npmPackagecount);
	var DataString = DataArray.join(";");

	channels[channelNo].send(DataString);
	sentPktCounter = 0;

	setTimeout(funct, stat.npmParameterSleep);

	npmPaket = "a";
	for (var j = 0; j < stat.npmSize; j++) {
		npmPaket += "a";
	}
	NpmSend(channelNo, npmPaket);
}

// bind the channel events
function bindEvents(channel) {
	channel.onopen = function() {
		$('#dc_' + channel.label + ' span.status').html('open <button onclick="closeDataChannel(\'' + channel.label + '\');">close</button>');
		console.log("Channel Open - Label:" + channel.label + ', ID:' + channel.id);
	};

	channel.onclose = function(e) {
		$('#dc_' + channel.label + ' span.status').html(channel.readyState);
		console.log("Channel Close");
	};

	window.onbeforeunload = function() {
		channel.close();
	};

	channel.onmessage = function(e) {
		rxData = e.data.toString();
		console.log("Message for "+e.currentTarget.label+" - content:"+rxData);
		var tempChannelLabel = e.currentTarget.label;
		var rxnpmPaketTemp = rxData.split(";");

		if (rxnpmPaketTemp[0] == 1) {
			//alert("start test");
			messageencoder = 1;
		} else
			messageencoder = 2;

		switch(messageencoder) {
			case 1:
				stats[tempChannelLabel].npmSizePerX = 0;
				stats[tempChannelLabel].t_counter = 0;
				stats[tempChannelLabel].npmPackagecount = 0;
				var rxDataString = rxData;
				var rxDataArray = rxDataString.split(";");
				stats[tempChannelLabel].npmParameterSleep = parseInt(rxDataArray[1]);
				console.log(stats[tempChannelLabel].npmParameterSleep);
				stats[tempChannelLabel].npmSize = parseInt(rxDataArray[2]);
				npmSizetemp = stats[tempChannelLabel].npmSize;
				stats[tempChannelLabel].npmPackagecount = rxDataArray[3];

				stats[tempChannelLabel].t_start = new Date().getTime();
				//alert(stats[tempChannelLabel].t_start);
				break;
			case 2:
				//alert(stats[tempChannelLabel].t_start);
				stats[tempChannelLabel].t_end = new Date().getTime();

				var returnArray = calculation(stats[tempChannelLabel].npmSize, npmSizetemp, stats[tempChannelLabel].t_start, stats[tempChannelLabel].t_end, t_startNewPackage, tempChannelLabel);
				stats[tempChannelLabel].npmSize = returnArray[0];
				npmSizetemp = returnArray[1];

				stats[tempChannelLabel].npmSize = stats[tempChannelLabel].npmSize + npmSizetemp;
				t_startNewPackage = new Date().getTime();
				stats[tempChannelLabel].t_counter++;
				if (stats[tempChannelLabel].t_counter == stats[tempChannelLabel].npmPackagecount) {
					alert("test completes successfully");
				}
				break;
		}
	};
}

function calculation(size, sizetemp, start, end, startNewPackage, channelLabel) {
	stats[channelLabel].npmSize = parseInt(size);
	npmSizetemp = parseInt(sizetemp);
	stats[channelLabel].t_start = parseInt(start);
	stats[channelLabel].t_end = parseInt(end);
	t_startNewPackage = parseInt(startNewPackage);

	//t_duration musst > 0
	t_duration = stats[channelLabel].t_end - stats[channelLabel].t_start;
	if (t_duration < 1)
		t_duration = 1;

	//calculate the average of Byte/s
	stats[channelLabel].npmSizePerX = parseFloat((stats[channelLabel].npmSize * (1 / (t_duration / 1000))) / 1024);
	stats[channelLabel].npmSizePerX = parseFloat(stats[channelLabel].npmSizePerX * 1000);
	stats[channelLabel].npmSizePerX2 = Math.round(stats[channelLabel].npmSizePerX);
	stats[channelLabel].npmSizePerX2 = stats[channelLabel].npmSizePerX2 / 1000;
	stats[channelLabel].npmSizePerX3 = (stats[channelLabel].npmSizePerX2 / 1024) * 1000000;
	stats[channelLabel].npmSizePerX3 = Math.round(stats[channelLabel].npmSizePerX3);
	stats[channelLabel].npmSizePerX3 = stats[channelLabel].npmSizePerX3 / 1000000;

	//calculazion of the current Byte/s
	stats[channelLabel].npmSizePerX = (Math.round(((npmSizetemp * (1 / ((stats[channelLabel].t_end - t_startNewPackage) / 1000))) / 1024) * 1000)) / 1000;

	$('div#log').html("<div>current<br>" + stats[channelLabel].npmSizePerX + " " + (stats[channelLabel].t_counter + 1) + " kByte/s<br>average<br>" + stats[channelLabel].npmSizePerX2 + " kByte/s<br>" + stats[channelLabel].npmSizePerX3 + " MByte/s</div>");

	console.log("GesGr.=" + stats[channelLabel].npmSize + " Byte/s=" + stats[channelLabel].npmSizePerX + " kByte/s=" + stats[channelLabel].npmSizePerX2 + " MByte/s=" + stats[channelLabel].npmSizePerX3 + " Start=" + stats[channelLabel].t_start + " Ende=" + stats[channelLabel].t_end + " GesT=" + t_duration);

	return [stats[channelLabel].npmSize, npmSizetemp];
}
