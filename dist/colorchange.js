

/*
 BASED ON: http://louisstow.github.io/WebRTC/datachannels.html
 */

var dcCounter = 0;
var activeChannelCount = new Array();
var parameters = new Array();
var labelButtonToggle = false;

var datachannel;

// get a reference to our FireBase database and child element: rooms
var dbRef = new Firebase("https://webrtc-data-channel.firebaseio.com/");
var roomRef = dbRef.child("rooms");

// shims - wrappers for webkit and mozilla connections
var PeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
var IceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
var SessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.RTCSessionDescription;


function gyroInit() {
	if (window.DeviceOrientationEvent) {
		$('#gyrostatus').removeClass('alert-danger').addClass('alert-success');
		// Listen for the deviceorientation event and handle the raw data
		window.addEventListener('deviceorientation', function(eventData) {
			// gamma is the left-to-right tilt in degrees, where right is positive
			
			var gammaRaw = Math.round(event.gamma);
			var gamma = Math.round((Math.abs(eventData.gamma) * 2.83) % 255);

			// beta is the front-to-back tilt in degrees, where front is positive
			var betaRaw = Math.round(event.beta);
			var beta = Math.round((Math.abs(eventData.beta) *1.41 )% 255);

			// alpha is the compass direction the device is facing in degrees
			var alphaRaw = Math.round(event.alpha);
			var alpha = Math.round((Math.abs(eventData.alpha-180) / 0.7)% 255);
			
			$('#gyrostatus').html('alpha:' + alpha + ' beta:' + beta + ' gamma:' + gamma + '<br />' + 'alpha:' + alphaRaw + ' beta:' + betaRaw + ' gamma:' + gammaRaw );
			
			
			//$(document.body).css('background-color','rgb('+alpha+','+beta+','+gamma+')');​​​​​​​​​​​​​​​
			$('body').css('background-color','rgb('+alpha+','+beta+','+gamma+')');
			
			if(datachannel.readyState === "open") {
				datachannel.send(alpha+','+beta+','+gamma);
			}
			
			// call our orientation event handler
		}, false);
	}
}


// #### Functions
// generate a unique-ish string for storage in firebase
function id() {
	return (Math.random() * 10000 + 10000 | 0).toString();
}

// wrapper to send data to FireBase
// - room: 	room id - generated by id()-function or read from url
function send(room, key, data) {
	roomRef.child(room).child(key).set(data);
}

// wrapper function to receive data from FireBase
function recv(room, type, cb) {
	roomRef.child(room).child(type).on("value", function(snapshot, key) {
		var data = snapshot.val();
		if (data) {
			cb(data);
		}
	});
}

// generic error handler
function errorHandler(err) {
	console.error(err);
}

// determine what type of peer we are,
// offerer or answerer.
var ROOM = location.hash.substr(1);
var type = "answerer";
var otherType = "offerer";

// no room number specified, so create one
// which makes us the offerer
if (!ROOM) {
	ROOM = id();
	type = "offerer";
	otherType = "answerer";
	$('#link').append(" (offerer) - <a href='#" + ROOM + "'>" + ROOM + "</a>");
}

if (type === "answerer") {
	$('#link').append(" (answerer) - " + ROOM);
	$('.controlContainer').hide();
};

// options for the PeerConnection
var iceServer = {
	iceServers : [{
		url : "stun:23.21.150.121"
	}, {
		url : "stun:stun.l.google.com:19302"
	}, {
		url : "turn:numb.viagenie.ca",
		credential : "webrtcdemo",
		username : "louis%40mozilla.com"
	}]
};

// create the PeerConnection
var pc = new PeerConnection(iceServer);

pc.onicecandidate = function(e) {
	// take the first candidate that isn't null
	if (!e.candidate) {
		return;
	}
	pc.onicecandidate = null;

	// request the other peers ICE candidate
	recv(ROOM, "candidate:" + otherType, function(candidate) {
		pc.addIceCandidate(new IceCandidate(JSON.parse(candidate)));
	});

	// send our ICE candidate
	send(ROOM, "candidate:" + type, JSON.stringify(e.candidate));
	
};


// constraints on the offer SDP.
var constraints = {};

// define the channel var
var channels = Array();

connect();

// start start peer connection
function connect() {
	if (type === "offerer") {
		    var dataChannelOptions = {
        maxPacketLifeTime : 1000
    };
		datachannel = pc.createDataChannel('gyrochannel',dataChannelOptions);
		bindEvents(datachannel);
		// create the offer SDP
		pc.createOffer(function(offer) {
			pc.setLocalDescription(offer);

			// send the offer SDP to FireBase
			send(ROOM, "offer", JSON.stringify(offer));

			// wait for an answer SDP from FireBase
			recv(ROOM, "answer", function(answer) {
				pc.setRemoteDescription(new SessionDescription(JSON.parse(answer)));
			});
		}, errorHandler, constraints);

		console.log("creating offer");

	} else {
		$('#createDataChannel').prop("disabled", true);
		// Button "createDataChannel" disabled for answerer

		// answerer must wait for the data channel
		pc.ondatachannel = function(e) {
			datachannel = e.channel;
			bindEvents(datachannel);
			console.log('incoming datachannel');
		};

		// answerer needs to wait for an offer before
		// generating the answer SDP
		recv(ROOM, "offer", function(offer) {
			pc.setRemoteDescription(new SessionDescription(JSON.parse(offer)));

			// now we can generate our answer SDP
			pc.createAnswer(function(answer) {
				pc.setLocalDescription(answer);

				// send it to FireBase
				send(ROOM, "answer", JSON.stringify(answer));
			}, errorHandler, constraints);
		});
		console.log('connect passive');
	}
}




// bind the channel events
function bindEvents(channel) {
	channel.onopen = function() {
		$('#dc_' + channel.label + ' span.status').html('open <button onclick="closeDataChannel(\'' + channel.label + '\');">close</button>');
		console.log("Channel Open - Label:" + channel.label + ', ID:' + channel.id);
	};

	channel.onclose = function(e) {
		console.log("Channel Close");
	};

	window.onbeforeunload = function() {
		channel.close();
	};

	channel.onmessage = function(e) {
		rxData = e.data.toString();
		$('body').css('background-color','rgb('+rxData+')');
		console.log("Message for "+e.currentTarget.label+" - content:"+rxData);
	};
}


